# Задача №1 по наследованию (Раздел: Наследование — базовый класс и дочерний класс)
#
# Создайте базовый класс Animal с:
#  Конструктором __init__, принимающим name (имя животного) и сохраняющим его в атрибут.
#  Методом speak, который выводит: "Животное издаёт звук".
#
# Создайте дочерний класс Dog, который наследуется от Animal.
#  Переопределите метод speak так, чтобы он выводил: "Собака {name} говорит: Гав!".
#
# Создайте объект класса Dog с именем "Бобик".
#
# Вызовите метод speak для этого объекта.

# Решение:

class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(f"Животное издаёт звук")

class Dog(Animal):
    def speak(self):
        print(f"Собака {self.name} говорит: Гав!")

my_dog = Dog("Бобик")
my_dog.speak()


# Задача №2 по наследованию (Раздел: Наследование — вызов методов родителя)
#
# Создайте базовый класс Vehicle с:
#  Конструктором __init__, принимающим brand (марка) и сохраняющим его в атрибут.
#  Методом start, который выводит: "Двигатель {brand} запущен".
#
# Создайте дочерний класс Car, который наследуется от Vehicle.
#  Добавьте в конструктор параметр model (модель) и сохраните его как атрибут.
#  В конструкторе дочернего класса вызовите конструктор родителя, передав ему brand.
#  Переопределите метод start так, чтобы он:
#   Сначала вызывал метод start родителя (через super()).
#   Затем выводил дополнительную строку: "Автомобиль {brand} {model} готов к поездке".
#
# Создайте объект класса Car с маркой "Toyota" и моделью "Camry".
# Вызовите метод start для этого объекта.

# Решение:

class Vehicle:
    def __init__(self, brand):
        self.brand = brand

    def start(self):
        print(f"Двигатель {self.brand} запущен")

class Car(Vehicle):
    def __init__(self, brand, model):
        super().__init__(brand)
        self.model = model

    def start(self):
        super().start()
        print(f"Автомобиль {self.brand} {self.model} готов к поездке")

my_car = Car("Toyota", "Camry")

my_car.start()


# Задача №3 по наследованию (базовый уровень)
#
# Создайте базовый класс Transport с:
#  Конструктором __init__, принимающим brand (марка) и сохраняющим его в атрибут.
#  Методом move, который выводит: "Транспорт движется".
#
# Создайте дочерний класс Bus, который наследуется от Transport.
#  Переопределите метод move так, чтобы он выводил: "Автобус {brand} везёт пассажиров".
#
# Создайте объект класса Bus с маркой "Mercedes".
#
# Вызовите метод move для этого объекта.

# Решение:

class Transport:
    def __init__(self, brand):
        self.brand = brand
    def move(self):
        print(f"Транспорт движется")

class Bus(Transport):
    def move(self):
        print(f"Автобус {self.brand} везёт пассажиров")

Bus_1 = Bus("Mercedes")
Bus_1.move()


# Задача №4 по наследованию (базовый уровень)
#
# Создайте базовый класс Device с:
#  Конструктором __init__, принимающим name (название устройства) и сохраняющим его в атрибут.
#  Методом turn_on, который выводит: "Устройство включено".
#
# Создайте дочерний класс Laptop, который наследуется от Device.
#  Добавьте в конструктор параметр battery_level (уровень заряда) и сохраните его как атрибут.
#  В конструкторе дочернего класса вызовите конструктор родителя, передав ему name.
#  Переопределите метод turn_on так, чтобы он:
#
#   Сначала вызывал метод turn_on родителя (через super()).
#   Затем выводил дополнительную строку: "Ноутбук {name} готов к работе, заряд: {battery_level}%".
#
# Создайте объект класса Laptop с названием "Dell XPS" и уровнем заряда 85.
#
# Вызовите метод turn_on для этого объекта.

# Решение:

class Device:
    def __init__(self, brand):
        self.brand = brand

    def turn_on(self):
        print(f"Устройство включено")

class Laptop(Device):
    def __init__(self, brand,  battery_level):
        super().__init__(brand)
        self.battery_level = battery_level

    def turn_on(self):
        super().turn_on()
        print(f"Ноутбук {self.brand} готов к работе, заряд: {self.battery_level}%")

my_laptop = Laptop("Dell XPS", 85)
my_laptop.turn_on()












