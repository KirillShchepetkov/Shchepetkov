# Задача №1 по функциям (Раздел: Создание и вызов функций)
#
# Создайте функцию с именем greet, которая:
# Принимает один аргумент — имя пользователя (name).
# Выводит на экран приветствие в формате: "Привет, {name}!"
# Вызовите эту функцию три раза с разными именами.
from curses import wrapper


# Решение:

def greet(name):
    print(f"Привет {name}!")
greet("Kirill")
greet("Elena")
greet("Fidel")

# Задача №2 по функциям (Раздел: Возвращение данных из функций)
#
# Создайте функцию с именем multiply, которая:
# Принимает два числовых аргумента.
# Возвращает результат их умножения, а не выводит его.
# Вызовите эту функцию, передав ей любые два числа.
# Сохраните результат в переменную result.
# Выведите значение переменной result на экран.

# Решение:

def multiply(a, b):
     return a * b
result = multiply(2, 3)
print(result)

# Задача №3 по функциям (Раздел: Аргументы с дефолтными значениями)
#
# Создайте функцию connect, которая:
# Принимает два параметра: host (обязательный) и port (необязательный).
# Параметр port должен иметь значение по умолчанию 8080.
# Функция выводит на экран строку в формате: "Подключение к {host}:{port}".
# Вызовите функцию два раза:
# Первый раз — передав только аргумент host (например, "localhost").
# Второй раз — передав оба аргумента (например, "example.com" и 9090).

# Решение:

def connect(host, port = 8080):
    print(f"Подключение к {host}:{port}")
connect("localhost")
connect("example.com", 9090)

# Задача №4 по функциям (Раздел: Декораторы)
#
# Создайте простую функцию say_hello(), которая выводит "Привет!".
# Создайте декоратор simple_decorator, который:
# Принимает функцию как аргумент.
# Внутри себя определяет вложенную функцию wrapper().
#
# В wrapper() сначала выводит строку "=== Начало ===",
# затем вызывает исходную функцию, затем выводит "=== Конец ===".
#
# Возвращает wrapper.
# Примените декоратор к функции say_hello() с помощью синтаксиса @.
# Вызовите декорированную функцию.

# Решение:

def simple_decorator(func):
    def wrapper():
        print(f"=== Начало ===")
        func()
        print("=== Конец ===")
    return wrapper
@simple_decorator
def say_hello():
    print("Привет!")

# Задача №5 по функциям (Раздел: Аргументы функций — позиционные и именованные)
#
# Создайте функцию create_user, которая принимает три обязательных параметра:
# name — имя пользователя
# age — возраст
# city — город
# Функция должна выводить на экран строку в формате:
# "Пользователь {name}, {age} год, проживает в {city}"
# Вызовите функцию два раза:
# Первый раз — передав аргументы позиционно (по порядку).
# Второй раз — передав аргументы именованно (в другом порядке, используя имена параметров).

# Решение:

def create_user(name, age, city):
    print(f"Пользователь {name}, {age} год, проживает в {city}")
create_user("Кирилл", 31, "Москва")

create_user(city = "Москва", age = 31, name = "Кирилл")

# Задача №6 по функциям (Раздел: Возвращение данных из функций)
#
# Создайте функцию is_even, которая:
# Принимает один числовой аргумент.
# Возвращает True, если число чётное, и False в противном случае.
# Создайте список чисел: numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].
# Используя цикл for и созданную функцию, выведите на экран только чётные числа из списка (каждое с новой строки).
# Подсказка: Внутри цикла используйте if is_even(number): для проверки.

# Решение:

def is_even(a):
    return a % 2 == 0

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for numb in numbers:
    if is_even(numb):
        print(numb)
        # очень долгая задача

# Задача №7 по функциям (Раздел: Аргументы с дефолтными значениями)
#
# Создайте функцию make_request, которая:
# Принимает два параметра: url (обязательный) и timeout (необязательный).
# Параметр timeout должен иметь значение по умолчанию 30.
# Функция выводит на экран строку в формате: "Запрос к {url} с таймаутом {timeout} сек".
#
# Вызовите функцию три раза:
# Первый раз — передав только url (например, "google.com").
# Второй раз — передав оба аргумента позиционно (например, "example.com" и 10).
# Третий раз — передав аргументы именованно (например, timeout=15, url="yandex.ru").

# Решение:

def make_request(url, timeout = 30):
    print(f"Запрос к {url} с таймаутом {timeout} сек")

make_request("google.com")

make_request("example.com",10)

make_request(timeout=15, url="yandex.ru")

# Задача №8 по функциям (Раздел: Декораторы)
#
# Создайте простую функцию add, которая:
# Принимает два числа.
# Возвращает их сумму.
# Создайте декоратор double_result, который:
# Принимает функцию как аргумент.
# Определяет вложенную функцию wrapper, которая принимает те же аргументы, что и исходная функция.
# Внутри wrapper вызывает исходную функцию и умножает её результат на 2.
# Возвращает результат умножения.
# Возвращает wrapper.
# Примените декоратор @double_result к функции add.
# Вызовите декорированную функцию с числами 4 и 7 и выведите результат.
#
# Пример: Если функция add возвращает 11, декоратор должен вернуть 22.

# Решение:

def add(a,b):
    return a+b

def double_result(func):
    def wrapper(a,b):
        result = func(a,b)
        return result * 2
    return wrapper

@double_result
def add(a,b):
    return a+b

print(add(4,7))

        
# Задача №9 по функциям (Раздел: Возвращение данных из функций)
#
# Создайте функцию get_status_message, которая:
# Принимает один аргумент — HTTP-код ответа (целое число).
# Возвращает строку с описанием кода по следующим правилам:
#
# 200 → "OK"
# 404 → "Not Found"
# 500 → "Internal Server Error"
# Любой другой код → "Unknown Status"
# Создайте список кодов: codes = [200, 404, 500, 301, 200, 403].
# Используя цикл for и созданную функцию,
# выведите на экран для каждого кода строку в формате: "Код {code}: {описание}".

# Решение:

def get_status_message(a):
    if a == 200:
        return "OK"
    elif a == 404:
        return "Not Found"
    elif a == 500:
        return "Internal Server Error"
    else:
        return "Unknown Status"

codes = [200, 404, 500, 301, 200, 403]

for code in codes:
    message = get_status_message(code)
    print(f"Код {code}: {message}")


# Задача №10 по функциям (Раздел: Аргументы с дефолтными значениями)
#
# Создайте функцию log_message, которая:
# Принимает два параметра: level (обязательный) и message (обязательный).
# Выводит на экран строку в формате: "[{level}] {message}".
# Создайте функцию log_with_default, которая:
# Принимает параметр message (обязательный) и необязательный параметр level со значением по умолчанию "INFO".
# Внутри себя вызывает функцию log_message, передавая ей соответствующие аргументы.
# Вызовите функцию log_with_default три раза:
#
# Первый раз — только с сообщением "Программа запущена".
# Второй раз — с сообщением "Ошибка подключения" и уровнем "ERROR".
# Третий раз — с сообщением "Отладка" и уровнем "DEBUG".

# Решение:

def log_message(level, message):
    print(f"[{level}] {message}")

def log_with_default(message, level = "INFO"):
    log_message(level, message)

log_with_default("Программа запущена")

log_with_default("Ошибка подключения","ERROR")

log_with_default("Отладка","DEBUG")


# Задача №11 по функциям (Раздел: Возвращение данных из функций)
#
# Создайте функцию calculate_average, которая:
# Принимает список чисел.
# Возвращает среднее арифметическое этих чисел.
# Если список пуст, функция должна возвращать 0.
#
# Создайте три списка:
#
# grades1 = [85, 90, 78, 92]
#
# grades2 = []
#
# grades3 = [45, 67, 89, 23, 56]
#
# Для каждого списка:
# Вызовите функцию calculate_average.
# Выведите результат в формате: "Среднее: {среднее}".

# Решение:

def calculate_average(numbers):
    if len(numbers) == 0:
        return 0
    total = sum(numbers)
    count = len(numbers)
    return total / count


grades1 = [85, 90, 78, 92]
avg1 = calculate_average(grades1)
print(f"Среднее: {avg1}")

grades2 = []
avg2 = calculate_average(grades2)
print(f"Среднее: {avg2}")

grades3 = [45, 67, 89, 23, 56]
avg3 = calculate_average(grades3)
print(f"Среднее: {avg3}")


# Задача №12 по функциям (Раздел: Декораторы)
#
# Создайте простую функцию greet, которая:
#
# Принимает один аргумент — имя пользователя.
# Возвращает строку "Привет, {name}!".
# Создайте декоратор uppercase_decorator, который:
# Принимает функцию как аргумент.
# Определяет вложенную функцию wrapper, принимающую те же аргументы, что и исходная функция.
# Внутри wrapper вызывает исходную функцию и преобразует результат в верхний регистр.
# Возвращает результат преобразования.
# Возвращает wrapper.
# Примените декоратор @uppercase_decorator к функции greet.
# Вызовите декорированную функцию с именем "Анна" и выведите результат

# Решение:

def uppercase_decorator(func):
    def wrapper(name):
        result = func(name)
        return result.upper()
    return wrapper

@uppercase_decorator
def greet(name):
    return f"Привет, {name}!"

print(greet("Анна"))

# Задача №13 по функциям (Раздел: Аргументы функций)
#
# Создайте функцию describe_person, которая принимает три обязательных параметра:
# name — имя
# age — возраст
# profession — профессия
#
# Функция должна возвращать строку в формате:
# "{name}, {age} лет, работает как {profession}"
#
# Создайте список словарей с данными о людях:
#
# people = [
#     {"name": "Анна", "age": 28, "profession": "тестировщик"},
#     {"name": "Борис", "age": 34, "profession": "разработчик"},
#     {"name": "Виктория", "age": 42, "profession": "аналитик"}
# ]
# Используя цикл for и созданную функцию, выведите описание каждого человека на экран
# При вызове функции используйте распаковку словаря: describe_person(**person)

# Решение:

def describe_person(name, age, profession):
    return f"{name}, {age} лет, работает как {profession}"

people = [
     {"name": "Анна", "age": 28, "profession": "тестировщик"},
     {"name": "Борис", "age": 34, "profession": "разработчик"},
     {"name": "Виктория", "age": 42, "profession": "аналитик"}
]

for person in people:
    print(describe_person(**person))


# Задача №14 по функциям (Раздел: Аргументы с дефолтными значениями)
#
# Создайте функцию create_user_profile, которая принимает:
# Обязательный параметр username.
# Необязательные параметры со значениями по умолчанию:
#
# role = "user"
# is_active = True
#
# Функция должна возвращать словарь с данными пользователя в формате:
#
# python
# {
#     "username": username,
#     "role": role,
#     "active": is_active
# }
# Создайте список с различными наборами аргументов:
#
# python
# users_data = [
#     {"username": "alice"},                           # только username
#     {"username": "bob", "role": "admin"},            # username + role
#     {"username": "charlie", "is_active": False},     # username + is_active
#     {"username": "diana", "role": "moderator", "is_active": True}  # все параметры
# ]
# Для каждого элемента списка вызовите функцию create_user_profile,
# используя распаковку словаря (**data), и выведите полученный профиль на экран.
#
# Каждый профиль должен выводиться с новой строки.

# Решение:

def create_user_profile(username, role = "user", is_active = True):
    return {
    "username": username,
    "role": role,
    "active": is_active
 }

users_data = [
     {"username": "alice"},                           # только username
     {"username": "bob", "role": "admin"},            # username + role
     {"username": "charlie", "is_active": False},     # username + is_active
     {"username": "diana", "role": "moderator", "is_active": True}  # все параметры
 ]

for data in users_data:
    profile = create_user_profile(**data)
    print(profile)

# Задача №15 по функциям (Раздел: Возвращение данных из функций)
#
# Создайте функцию analyze_numbers, которая:
# Принимает список чисел.
# Возвращает кортеж (tuple) из трёх элементов:
# Минимальное число
# Максимальное число
# Сумма всех чисел
# Создайте список: numbers = [12, 45, 7, 89, 23, 56, 34].
# Вызовите функцию для этого списка и сохраните результат в переменную result.
# Выведите результат на экран в формате:
#
# text
# Минимум: <мин>
# Максимум: <макс>
# Сумма: <сумма>
# Подсказки: Используйте встроенные функции min(), max(), sum().

# Решение:

def analyze_numbers(numbers):
    return min(numbers), max(numbers), sum(numbers)

numbers = [12, 45, 7, 89, 23, 56, 34]

result = analyze_numbers(numbers)
print(f"Минимум: {result[0]}")
print(f"Максимум: {result[1]}")
print(f"Сумма: {result[2]}")


# Задача №16 по функциям (Раздел: Декораторы)
#
# Создайте простую функцию square, которая:
# Принимает одно число.
# Возвращает квадрат этого числа.
# Создайте декоратор double_result, который:
# Принимает функцию как аргумент.
# Определяет вложенную функцию wrapper, принимающую те же аргументы, что и исходная функция.
# Внутри wrapper вызывает исходную функцию и умножает её результат на 2.
# Возвращает результат умножения.
# Возвращает wrapper.
# Примените декоратор @double_result к функции square.
# Вызовите декорированную функцию с числом 5 и выведите результат.
#
# Пример: Функция square(5) возвращает 25, декоратор должен вернуть 50

# Решение:

def square(func):
     def wrapper(a):
         result = func(a**2)*2
         return result
     return wrapper

@double_result

def square():
    print(square(5))






