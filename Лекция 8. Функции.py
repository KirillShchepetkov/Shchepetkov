# Задача №1 по функциям (Раздел: Создание и вызов функций)
#
# Создайте функцию с именем greet, которая:
# Принимает один аргумент — имя пользователя (name).
# Выводит на экран приветствие в формате: "Привет, {name}!"
# Вызовите эту функцию три раза с разными именами.
from curses import wrapper


# Решение:

def greet(name):
    print(f"Привет {name}!")
greet("Kirill")
greet("Elena")
greet("Fidel")

# Задача №2 по функциям (Раздел: Возвращение данных из функций)
#
# Создайте функцию с именем multiply, которая:
# Принимает два числовых аргумента.
# Возвращает результат их умножения, а не выводит его.
# Вызовите эту функцию, передав ей любые два числа.
# Сохраните результат в переменную result.
# Выведите значение переменной result на экран.

# Решение:

def multiply(a, b):
     return a * b
result = multiply(2, 3)
print(result)

# Задача №3 по функциям (Раздел: Аргументы с дефолтными значениями)
#
# Создайте функцию connect, которая:
# Принимает два параметра: host (обязательный) и port (необязательный).
# Параметр port должен иметь значение по умолчанию 8080.
# Функция выводит на экран строку в формате: "Подключение к {host}:{port}".
# Вызовите функцию два раза:
# Первый раз — передав только аргумент host (например, "localhost").
# Второй раз — передав оба аргумента (например, "example.com" и 9090).

# Решение:

def connect(host, port = 8080):
    print(f"Подключение к {host}:{port}")
connect("localhost")
connect("example.com", 9090)

# Задача №4 по функциям (Раздел: Декораторы)
#
# Создайте простую функцию say_hello(), которая выводит "Привет!".
# Создайте декоратор simple_decorator, который:
# Принимает функцию как аргумент.
# Внутри себя определяет вложенную функцию wrapper().
#
# В wrapper() сначала выводит строку "=== Начало ===",
# затем вызывает исходную функцию, затем выводит "=== Конец ===".
#
# Возвращает wrapper.
# Примените декоратор к функции say_hello() с помощью синтаксиса @.
# Вызовите декорированную функцию.

# Решение:

def simple_decorator(func):
    def wrapper():
        print(f"=== Начало ===")
        func()
        print("=== Конец ===")
    return wrapper
@simple_decorator
def say_hello():
    print("Привет!")

# Задача №5 по функциям (Раздел: Аргументы функций — позиционные и именованные)
#
# Создайте функцию create_user, которая принимает три обязательных параметра:
# name — имя пользователя
# age — возраст
# city — город
# Функция должна выводить на экран строку в формате:
# "Пользователь {name}, {age} год, проживает в {city}"
# Вызовите функцию два раза:
# Первый раз — передав аргументы позиционно (по порядку).
# Второй раз — передав аргументы именованно (в другом порядке, используя имена параметров).

# Решение:

def create_user(name, age, city):
    print(f"Пользователь {name}, {age} год, проживает в {city}")
create_user("Кирилл", 31, "Москва")

create_user(city = "Москва", age = 31, name = "Кирилл")

# Задача №6 по функциям (Раздел: Возвращение данных из функций)
#
# Создайте функцию is_even, которая:
# Принимает один числовой аргумент.
# Возвращает True, если число чётное, и False в противном случае.
# Создайте список чисел: numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].
# Используя цикл for и созданную функцию, выведите на экран только чётные числа из списка (каждое с новой строки).
# Подсказка: Внутри цикла используйте if is_even(number): для проверки.

# Решение:

def is_even(a):
    return a % 2 == 0

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for numb in numbers:
    if is_even(numb):
        print(numb)
        # очень долгая задача

# Задача №7 по функциям (Раздел: Аргументы с дефолтными значениями)
#
# Создайте функцию make_request, которая:
# Принимает два параметра: url (обязательный) и timeout (необязательный).
# Параметр timeout должен иметь значение по умолчанию 30.
# Функция выводит на экран строку в формате: "Запрос к {url} с таймаутом {timeout} сек".
#
# Вызовите функцию три раза:
# Первый раз — передав только url (например, "google.com").
# Второй раз — передав оба аргумента позиционно (например, "example.com" и 10).
# Третий раз — передав аргументы именованно (например, timeout=15, url="yandex.ru").

# Решение:

def make_request(url, timeout = 30):
    print(f"Запрос к {url} с таймаутом {timeout} сек")

make_request("google.com")

make_request("example.com",10)

make_request(timeout=15, url="yandex.ru")

# Задача №8 по функциям (Раздел: Декораторы)
#
# Создайте простую функцию add, которая:
# Принимает два числа.
# Возвращает их сумму.
# Создайте декоратор double_result, который:
# Принимает функцию как аргумент.
# Определяет вложенную функцию wrapper, которая принимает те же аргументы, что и исходная функция.
# Внутри wrapper вызывает исходную функцию и умножает её результат на 2.
# Возвращает результат умножения.
# Возвращает wrapper.
# Примените декоратор @double_result к функции add.
# Вызовите декорированную функцию с числами 4 и 7 и выведите результат.
#
# Пример: Если функция add возвращает 11, декоратор должен вернуть 22.

# Решение:

def add(a,b):
    return a+b

def double_result(func):
    def wrapper(a,b):
        result = func(a,b)
        return result * 2
    return wrapper

@double_result
def add(a,b):
    return a+b

print(add(4,7))

        
# Задача №9 по функциям (Раздел: Возвращение данных из функций)
#
# Создайте функцию get_status_message, которая:
# Принимает один аргумент — HTTP-код ответа (целое число).
# Возвращает строку с описанием кода по следующим правилам:
#
# 200 → "OK"
# 404 → "Not Found"
# 500 → "Internal Server Error"
# Любой другой код → "Unknown Status"
# Создайте список кодов: codes = [200, 404, 500, 301, 200, 403].
# Используя цикл for и созданную функцию,
# выведите на экран для каждого кода строку в формате: "Код {code}: {описание}".

# Решение:

def get_status_message(a):
    if a == 200:
        return "OK"
    elif a == 404:
        return "Not Found"
    elif a == 500:
        return "Internal Server Error"
    else:
        return "Unknown Status"

codes = [200, 404, 500, 301, 200, 403]

for code in codes:
    message = get_status_message(code)
    print(f"Код {code}: {message}")






